generator client {
    provider = "prisma-client"
    output   = "../master-client-types"
}

datasource db {
    provider = "postgresql"
}

// --- Models ---

model User {
    id            String    @id @default(uuid())
    name          String
    email         String    @unique
    emailVerified Boolean   @default(false)
    image         String?
    role          String    @default("USER") // Using String for compatibility
    isActive      Boolean   @default(true)
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    deletedAt     DateTime?

    sessions    Session[]
    accounts    Account[]
    memberships TenantMember[]
    tenants     Tenant[]       @relation("TenantOwner")

    @@index([email])
    @@index([role])
    @@map("user")
}

model Session {
    id        String   @id @default(uuid())
    expiresAt DateTime
    token     String   @unique
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    ipAddress String?
    userAgent String?
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
    @@map("session")
}

model Account {
    id                    String    @id @default(uuid())
    accountId             String
    providerId            String
    userId                String
    user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    accessToken           String?
    refreshToken          String?
    idToken               String?
    accessTokenExpiresAt  DateTime?
    refreshTokenExpiresAt DateTime?
    scope                 String?
    password              String?
    createdAt             DateTime  @default(now())
    updatedAt             DateTime  @updatedAt

    @@unique([providerId, accountId])
    @@index([userId])
    @@map("account")
}

model Verification {
    id         String   @id @default(uuid())
    identifier String
    value      String
    expiresAt  DateTime
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt

    @@unique([identifier, value])
    @@map("verification")
}

model Tenant {
    id                   String  @id @default(uuid())
    name                 String
    slug                 String  @unique
    description          String?
    logo                 String?
    type                 String
    email                String
    phone                String
    address              String
    city                 String
    state                String
    postalCode           String?
    subdomain            String? @unique
    customDomain         String? @unique
    customDomainVerified Boolean @default(false)

    databaseName     String? @unique
    connectionString String?
    databaseStatus   String  @default("PENDING")

    studentCount  Int @default(0)
    teacherCount  Int @default(0)
    examCount     Int @default(0)
    storageUsedMB Int @default(0)

    isActive            Boolean @default(true)
    isSuspended         Boolean @default(false)
    suspendReason       String?
    currentAcademicYear String?
    metadata            Json    @default("{}")

    createdById String?
    owner       User?   @relation("TenantOwner", fields: [createdById], references: [id])

    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt
    deletedAt DateTime?

    // Custom limits (Overrides from plan)
    customStudentLimit Int?
    customTeacherLimit Int?
    customExamLimit    Int?
    customStorageLimit Int?

    subscription Subscription?
    members      TenantMember[]
    invitations  TenantInvitation[]

    @@index([slug])
    @@map("tenant")
}

model TenantMember {
    id        String   @id @default(uuid())
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    tenantId  String
    tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
    role      String   @default("STUDENT")
    isActive  Boolean  @default(true)
    joinedAt  DateTime @default(now()) @map("joinedAt")
    // Added updatedAt for standard tracking
    updatedAt DateTime @default(now()) @updatedAt

    @@unique([userId, tenantId])
    @@index([tenantId])
    @@index([userId])
    @@map("tenant_member")
}

model TenantInvitation {
    id         String    @id @default(uuid())
    tenantId   String
    tenant     Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
    email      String
    role       String    @default("TEACHER")
    token      String    @unique
    expiresAt  DateTime
    invitedBy  String
    acceptedAt DateTime?
    acceptedBy String?
    message    String?
    name       String? // Candidate name
    status     String    @default("PENDING")
    createdAt  DateTime  @default(now())
    updatedAt  DateTime  @updatedAt

    @@unique([email, tenantId])
    @@index([email])
    @@index([status])
    @@index([tenantId])
    @@index([token])
    @@map("tenant_invitation")
}

model SubscriptionPlan {
    id          String  @id @default(uuid())
    name        String  @unique
    displayName String
    description String?

    monthlyPriceBDT Int @default(0)
    yearlyPriceBDT  Int @default(0)
    monthlyPriceUSD Int @default(0)
    yearlyPriceUSD  Int @default(0)

    features  Json    @default("{}")
    isActive  Boolean @default(true)
    isPopular Boolean @default(false)

    defaultStudentLimit Int @default(10)
    defaultTeacherLimit Int @default(2)
    defaultExamLimit    Int @default(20)
    defaultStorageLimit Int @default(100) // MB? Centered on introspected data

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    subscriptions Subscription[]

    @@map("subscription_plan")
}

model Subscription {
    id       String           @id @default(uuid())
    tenantId String           @unique
    tenant   Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
    planId   String
    plan     SubscriptionPlan @relation(fields: [planId], references: [id])
    status   String

    currentPeriodStart DateTime
    currentPeriodEnd   DateTime
    trialEndsAt        DateTime?

    billingCycle  String @default("monthly")
    currency      String @default("BDT")
    pricePerMonth Int
    pricePerYear  Int?

    paymentProvider String?
    externalId      String?

    cancelAtPeriodEnd Boolean   @default(false)
    canceledAt        DateTime?
    cancelReason      String?

    customStudentLimit Int?
    customTeacherLimit Int?
    customExamLimit    Int?
    customStorageLimit Int?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    history SubscriptionHistory[]

    @@index([currentPeriodEnd])
    @@index([planId])
    @@index([status])
    @@index([tenantId])
    @@map("subscription")
}

model SubscriptionHistory {
    id             String       @id @default(uuid())
    subscriptionId String
    subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
    event          String
    fromPlanId     String?
    toPlanId       String?
    fromStatus     String?
    toStatus       String?
    reason         String?
    metadata       Json         @default("{}")
    createdBy      String?
    createdAt      DateTime     @default(now())

    @@index([createdAt])
    @@index([subscriptionId])
    @@map("subscription_history")
}

model Invoice {
    id            String @id @default(uuid())
    tenantId      String
    invoiceNumber String @unique
    amount        Int
    currency      String @default("BDT")
    status        String @default("PENDING")

    periodStart DateTime
    periodEnd   DateTime
    dueDate     DateTime?
    paidAt      DateTime?

    paymentMethod    String?
    paymentProvider  String?
    paymentReference String?

    pdfUrl      String? @map("invoicePdfUrl")
    lineItems   Json    @default("[]")
    description String?
    notes       String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([dueDate])
    @@index([invoiceNumber])
    @@index([status])
    @@index([tenantId])
    @@map("invoice")
}

model AcademicClass {
    id          String   @id @default(uuid())
    name        String   @unique
    level       String
    displayName String
    position    Int      @default(0)
    isActive    Boolean  @default(true)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    subjects AcademicSubject[]
    cqs      Cq[]

    @@index([isActive])
    @@index([name])
    @@map("academic_class")
}

model AcademicSubject {
    id          String        @id @default(uuid())
    name        String
    displayName String
    code        String?
    group       String?
    position    Int           @default(0)
    isActive    Boolean       @default(true)
    classId     String
    class       AcademicClass @relation(fields: [classId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    chapters AcademicChapter[]
    mcqs     Mcq[]
    cqs      Cq[]

    @@index([classId])
    @@index([isActive])
    @@map("academic_subject")
}

model AcademicChapter {
    id          String          @id @default(uuid())
    name        String
    displayName String
    position    Int             @default(0)
    isActive    Boolean         @default(true)
    subjectId   String
    subject     AcademicSubject @relation(fields: [subjectId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    topics AcademicTopic[]
    mcqs   Mcq[]
    cqs    Cq[]

    @@index([isActive])
    @@index([subjectId])
    @@map("academic_chapter")
}

model AcademicTopic {
    id          String          @id @default(uuid())
    name        String
    displayName String
    position    Int             @default(0)
    isActive    Boolean         @default(true)
    chapterId   String
    chapter     AcademicChapter @relation(fields: [chapterId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    subtopics AcademicSubTopic[]
    mcqs      Mcq[]
    cqs       Cq[]

    @@index([chapterId])
    @@index([isActive])
    @@map("academic_topic")
}

model AcademicSubTopic {
    id          String        @id @default(uuid())
    name        String
    displayName String
    position    Int           @default(0)
    isActive    Boolean       @default(true)
    topicId     String
    topic       AcademicTopic @relation(fields: [topicId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    mcqs Mcq[]
    cqs  Cq[]

    @@index([isActive])
    @@index([topicId])
    @@map("academic_subtopic")
}

model Mcq {
    id          String   @id @default(uuid())
    question    String
    answer      String
    options     String[]
    statements  String[] @default([])
    type        String
    isMath      Boolean  @default(false)
    reference   String[] @default([])
    explanation String?
    session     Int
    source      String?
    questionUrl String?
    context     String?
    contextUrl  String?

    subjectId  String
    chapterId  String
    topicId    String?
    subTopicId String?

    subject  AcademicSubject   @relation(fields: [subjectId], references: [id])
    chapter  AcademicChapter   @relation(fields: [chapterId], references: [id])
    topic    AcademicTopic?    @relation(fields: [topicId], references: [id])
    subtopic AcademicSubTopic? @relation(fields: [subTopicId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([chapterId])
    @@index([chapterId, type])
    @@index([isMath])
    @@index([session])
    @@index([subjectId, chapterId])
    @@index([subjectId])
    @@index([subjectId, type])
    @@index([type])
    @@index([type, session])
    @@map("Mcq") // Note: Introspected name was PascalCase for Mcq
}

model Cq {
    id        String  @id @default(uuid())
    questionA String
    questionB String
    questionC String
    questionD String
    context   String?
    marks     Float   @default(10)
    isActive  Boolean @default(true)

    classId    String
    subjectId  String
    chapterId  String
    topicId    String?
    subTopicId String?

    class    AcademicClass     @relation(fields: [classId], references: [id])
    subject  AcademicSubject   @relation(fields: [subjectId], references: [id])
    chapter  AcademicChapter   @relation(fields: [chapterId], references: [id])
    topic    AcademicTopic?    @relation(fields: [topicId], references: [id])
    subtopic AcademicSubTopic? @relation(fields: [subTopicId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([chapterId])
    @@index([classId])
    @@index([isActive])
    @@index([subjectId])
    @@map("cq")
}

model AuditLog {
    id          String  @id @default(uuid())
    action      String
    entity      String
    entityId    String?
    description String?
    metadata    Json?   @default("{}")
    ipAddress   String?
    userAgent   String?
    userId      String?
    tenantId    String?

    createdAt DateTime @default(now())

    @@index([action])
    @@index([createdAt])
    @@index([entity])
    @@index([tenantId])
    @@index([userId])
    @@map("audit_log")
}

model SystemSetting {
    id          String  @id @default(uuid())
    key         String  @unique
    value       String
    type        String  @default("string")
    description String?
    category    String? @map("category") // Introspected 'category'

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([category])
    @@map("system_setting")
}

model Notification {
    id          String  @id @default(uuid())
    title       String
    message     String
    type        String  @default("info")
    read        Boolean @default(false)
    actionUrl   String?
    actionLabel String?
    userId      String?
    tenantId    String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([createdAt])
    @@index([read])
    @@index([tenantId])
    @@index([userId])
    @@map("notification")
}

generator client {
    provider = "prisma-client"
    output   = "../master-client-types"
}

datasource db {
    provider = "postgresql"
}

// --- Models ---

model User {
    id            String    @id @default(uuid())
    name          String
    email         String    @unique
    emailVerified Boolean   @default(false)
    image         String?
    role          String    @default("USER")
    isActive      Boolean   @default(true)
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    deletedAt     DateTime?

    sessions    Session[]
    accounts    Account[]
    memberships TenantMember[]
    tenants     Tenant[]       @relation("TenantOwner")

    @@index([email])
    @@index([role])
    @@map("user")
}

model Session {
    id        String   @id @default(uuid())
    expiresAt DateTime
    token     String   @unique
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    ipAddress String?
    userAgent String?
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
    @@map("session")
}

model Account {
    id                    String    @id @default(uuid())
    accountId             String
    providerId            String
    userId                String
    user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    accessToken           String?
    refreshToken          String?
    idToken               String?
    accessTokenExpiresAt  DateTime?
    refreshTokenExpiresAt DateTime?
    scope                 String?
    password              String?
    createdAt             DateTime  @default(now())
    updatedAt             DateTime  @updatedAt

    @@unique([providerId, accountId])
    @@index([userId])
    @@map("account")
}

model Verification {
    id         String   @id @default(uuid())
    identifier String
    value      String
    expiresAt  DateTime
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt

    @@unique([identifier, value])
    @@map("verification")
}

model Tenant {
    id                   String  @id @default(uuid())
    name                 String
    slug                 String  @unique
    description          String?
    logo                 String?
    type                 String
    email                String
    phone                String
    address              String
    city                 String
    state                String
    postalCode           String?
    subdomain            String? @unique
    customDomain         String? @unique
    customDomainVerified Boolean @default(false)

    databaseName     String? @unique
    connectionString String?
    databaseStatus   String  @default("PENDING")

    studentCount  Int @default(0)
    teacherCount  Int @default(0)
    examCount     Int @default(0)
    storageUsedMB Int @default(0)

    isActive            Boolean @default(true)
    isSuspended         Boolean @default(false)
    suspendReason       String?
    currentAcademicYear String?
    metadata            Json    @default("{}")

    // FIX: onDelete: SetNull because createdById is optional —
    //      deleting a User should not delete their Tenants, just clear the owner reference.
    createdById String?
    owner       User?   @relation("TenantOwner", fields: [createdById], references: [id], onDelete: SetNull)

    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt
    deletedAt DateTime?

    customStudentLimit Int?
    customTeacherLimit Int?
    customExamLimit    Int?
    customStorageLimit Int?

    subscription Subscription?
    members      TenantMember[]
    invitations  TenantInvitation[]

    @@index([slug])
    @@map("tenant")
}

model TenantMember {
    id        String   @id @default(uuid())
    userId    String
    tenantId  String
    role      String   @default("STUDENT")
    isActive  Boolean  @default(true)
    joinedAt  DateTime @default(now()) @map("joinedAt")
    // FIX: removed redundant @default(now()) — @updatedAt manages this automatically
    updatedAt DateTime @updatedAt

    // FIX: Cascade on both sides — a membership record is meaningless without its User or Tenant
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

    @@unique([userId, tenantId])
    @@index([tenantId])
    @@index([userId])
    @@map("tenant_member")
}

model TenantInvitation {
    id         String    @id @default(uuid())
    tenantId   String
    email      String
    role       String    @default("TEACHER")
    token      String    @unique
    expiresAt  DateTime
    invitedBy  String
    acceptedAt DateTime?
    acceptedBy String?
    message    String?
    name       String?
    status     String    @default("PENDING")
    createdAt  DateTime  @default(now())
    updatedAt  DateTime  @updatedAt

    // FIX: Cascade — invitations are owned by the tenant, delete with it
    tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

    @@unique([email, tenantId])
    @@index([email])
    @@index([status])
    @@index([tenantId])
    @@index([token])
    @@map("tenant_invitation")
}

model SubscriptionPlan {
    id          String  @id @default(uuid())
    name        String  @unique
    displayName String
    description String?

    monthlyPriceBDT Int @default(0)
    yearlyPriceBDT  Int @default(0)
    monthlyPriceUSD Int @default(0)
    yearlyPriceUSD  Int @default(0)

    features  Json    @default("{}")
    isActive  Boolean @default(true)
    isPopular Boolean @default(false)

    defaultStudentLimit Int @default(10)
    defaultTeacherLimit Int @default(2)
    defaultExamLimit    Int @default(20)
    defaultStorageLimit Int @default(100)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    subscriptions Subscription[]

    @@map("subscription_plan")
}

model Subscription {
    id       String @id @default(uuid())
    tenantId String @unique
    planId   String

    status String

    currentPeriodStart DateTime
    currentPeriodEnd   DateTime
    trialEndsAt        DateTime?

    billingCycle  String @default("monthly")
    currency      String @default("BDT")
    pricePerMonth Int
    pricePerYear  Int?

    paymentProvider String?
    externalId      String?

    cancelAtPeriodEnd Boolean   @default(false)
    canceledAt        DateTime?
    cancelReason      String?

    customStudentLimit Int?
    customTeacherLimit Int?
    customExamLimit    Int?
    customStorageLimit Int?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // FIX: Cascade — subscription is owned by tenant
    tenant Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
    // FIX: Restrict — prevent deleting a plan that has active subscriptions
    plan   SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Restrict)

    history SubscriptionHistory[]

    @@index([currentPeriodEnd])
    @@index([planId])
    @@index([status])
    @@index([tenantId])
    @@map("subscription")
}

model SubscriptionHistory {
    id             String   @id @default(uuid())
    subscriptionId String
    event          String
    fromPlanId     String?
    toPlanId       String?
    fromStatus     String?
    toStatus       String?
    reason         String?
    metadata       Json     @default("{}")
    createdBy      String?
    createdAt      DateTime @default(now())

    // FIX: Cascade — history is owned by the subscription
    subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

    @@index([createdAt])
    @@index([subscriptionId])
    @@map("subscription_history")
}

model Invoice {
    id            String @id @default(uuid())
    tenantId      String
    invoiceNumber String @unique
    amount        Int
    currency      String @default("BDT")
    status        String @default("PENDING")

    periodStart DateTime
    periodEnd   DateTime
    dueDate     DateTime?
    paidAt      DateTime?

    paymentMethod    String?
    paymentProvider  String?
    paymentReference String?

    pdfUrl      String? @map("invoicePdfUrl")
    lineItems   Json    @default("[]")
    description String?
    notes       String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // NOTE: tenantId is intentionally a bare FK string (no @relation) so that invoices
    //       are retained as financial records even if the Tenant is soft-deleted.
    //       If you want hard-delete cascade, add:
    //         tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
    //       and add `invoices Invoice[]` to the Tenant model.

    @@index([dueDate])
    @@index([invoiceNumber])
    @@index([status])
    @@index([tenantId])
    @@map("invoice")
}

// ---------------------------------------------------------------------------
// Academic hierarchy:  Class ←→ Subject (m-n)  →  Chapter → Topic → SubTopic
//
// FIX: The original schema used an implicit m-n between AcademicClass and
//      AcademicSubject. Implicit m-n relations in Prisma cannot have custom
//      onDelete/onUpdate referential actions. We convert it to an EXPLICIT
//      join model (AcademicClassSubject) so we can control cascade behaviour
//      and add metadata (e.g. a position per class-subject pair) in future.
//
// FIX: AcademicChapter previously had an ambiguous optional `academicClassId`
//      alongside the required `subjectId`. A chapter belongs to a subject;
//      the subject already carries its class memberships. The direct class
//      link on Chapter is therefore redundant and has been removed to avoid
//      inconsistency. If you genuinely need per-chapter class scoping, add it
//      back as a required FK with a clear business rule.
// ---------------------------------------------------------------------------

model AcademicClass {
    id          String   @id @default(uuid())
    name        String   @unique
    level       String
    displayName String
    position    Int      @default(0)
    isActive    Boolean  @default(true)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // FIX: explicit join table replaces the old implicit m-n `subjects AcademicSubject[]`
    classSubjects AcademicClassSubject[]
    cqs           Cq[]

    @@index([isActive])
    @@index([name])
    @@map("academic_class")
}

model AcademicSubject {
    id          String  @id @default(uuid())
    name        String
    displayName String
    code        String?
    group       String?
    position    Int     @default(0)
    isActive    Boolean @default(true)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // FIX: explicit join table replaces the old implicit m-n `classes AcademicClass[]`
    classSubjects AcademicClassSubject[]
    chapters      AcademicChapter[]
    mcqs          Mcq[]
    cqs           Cq[]

    @@index([isActive])
    @@map("academic_subject")
}

// FIX: Explicit many-to-many join table for AcademicClass ↔ AcademicSubject.
//      Cascade on both sides: removing a class or subject removes the mapping row,
//      not the other side's data.
model AcademicClassSubject {
    id        String   @id @default(uuid())
    classId   String
    subjectId String
    position  Int      @default(0) // optional ordering per class
    createdAt DateTime @default(now())

    academicClass   AcademicClass   @relation(fields: [classId], references: [id], onDelete: Cascade)
    academicSubject AcademicSubject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

    @@unique([classId, subjectId])
    @@index([classId])
    @@index([subjectId])
    @@map("academic_class_subject")
}

model AcademicChapter {
    id          String  @id @default(uuid())
    name        String
    displayName String
    position    Int     @default(0)
    isActive    Boolean @default(true)
    subjectId   String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // FIX: Restrict — don't silently delete chapters when a subject is deleted;
    //      require explicit cleanup so question data is not orphaned.
    subject AcademicSubject @relation(fields: [subjectId], references: [id], onDelete: Restrict)

    topics AcademicTopic[]
    mcqs   Mcq[]
    cqs    Cq[]

    @@index([isActive])
    @@index([subjectId])
    @@map("academic_chapter")
}

model AcademicTopic {
    id          String  @id @default(uuid())
    name        String
    displayName String
    position    Int     @default(0)
    isActive    Boolean @default(true)
    chapterId   String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // FIX: Restrict — preserve question integrity
    chapter AcademicChapter @relation(fields: [chapterId], references: [id], onDelete: Restrict)

    subtopics AcademicSubTopic[]
    mcqs      Mcq[]
    cqs       Cq[]

    @@index([chapterId])
    @@index([isActive])
    @@map("academic_topic")
}

model AcademicSubTopic {
    id          String  @id @default(uuid())
    name        String
    displayName String
    position    Int     @default(0)
    isActive    Boolean @default(true)
    topicId     String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // FIX: Restrict — preserve question integrity
    topic AcademicTopic @relation(fields: [topicId], references: [id], onDelete: Restrict)

    mcqs Mcq[]
    cqs  Cq[]

    @@index([isActive])
    @@index([topicId])
    @@map("academic_subtopic")
}

model Mcq {
    id          String   @id @default(uuid())
    question    String
    answer      String
    options     String[]
    statements  String[] @default([])
    type        String
    isMath      Boolean  @default(false)
    reference   String[] @default([])
    explanation String?
    session     Int
    source      String?
    questionUrl String?
    context     String?
    contextUrl  String?

    subjectId  String
    chapterId  String
    topicId    String?
    subTopicId String?

    // FIX: Restrict on required FKs — do not silently delete thousands of questions
    //      when an academic hierarchy node is removed. Force explicit cleanup.
    subject  AcademicSubject   @relation(fields: [subjectId], references: [id], onDelete: Restrict)
    chapter  AcademicChapter   @relation(fields: [chapterId], references: [id], onDelete: Restrict)
    // FIX: SetNull on optional FKs — topic/subtopic can be removed without losing the question
    topic    AcademicTopic?    @relation(fields: [topicId], references: [id], onDelete: SetNull)
    subtopic AcademicSubTopic? @relation(fields: [subTopicId], references: [id], onDelete: SetNull)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([chapterId])
    @@index([chapterId, type])
    @@index([isMath])
    @@index([session])
    @@index([subjectId, chapterId])
    @@index([subjectId])
    @@index([subjectId, type])
    @@index([type])
    @@index([type, session])
    @@map("Mcq")
}

model Cq {
    id        String  @id @default(uuid())
    questionA String
    questionB String
    questionC String
    questionD String
    context   String?
    marks     Float   @default(10)
    isActive  Boolean @default(true)

    classId    String
    subjectId  String
    chapterId  String
    topicId    String?
    subTopicId String?

    // FIX: Restrict on required FKs, SetNull on optional FKs (same rationale as Mcq)
    class    AcademicClass     @relation(fields: [classId], references: [id], onDelete: Restrict)
    subject  AcademicSubject   @relation(fields: [subjectId], references: [id], onDelete: Restrict)
    chapter  AcademicChapter   @relation(fields: [chapterId], references: [id], onDelete: Restrict)
    topic    AcademicTopic?    @relation(fields: [topicId], references: [id], onDelete: SetNull)
    subtopic AcademicSubTopic? @relation(fields: [subTopicId], references: [id], onDelete: SetNull)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([chapterId])
    @@index([classId])
    @@index([isActive])
    @@index([subjectId])
    @@map("cq")
}

// NOTE: AuditLog and Notification intentionally use bare String FKs for
//       userId / tenantId rather than @relation. This is the correct pattern
//       for append-only log/notification tables: records must survive the
//       deletion of the user or tenant they reference.
model AuditLog {
    id          String  @id @default(uuid())
    action      String
    entity      String
    entityId    String?
    description String?
    metadata    Json?   @default("{}")
    ipAddress   String?
    userAgent   String?
    userId      String?
    tenantId    String?

    createdAt DateTime @default(now())

    @@index([action])
    @@index([createdAt])
    @@index([entity])
    @@index([tenantId])
    @@index([userId])
    @@map("audit_log")
}

model SystemSetting {
    id          String  @id @default(uuid())
    key         String  @unique
    value       String
    type        String  @default("string")
    description String?
    category    String? @map("category")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([category])
    @@map("system_setting")
}

model Notification {
    id          String  @id @default(uuid())
    title       String
    message     String
    type        String  @default("info")
    read        Boolean @default(false)
    actionUrl   String?
    actionLabel String?
    userId      String?
    tenantId    String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([createdAt])
    @@index([read])
    @@index([tenantId])
    @@index([userId])
    @@map("notification")
}
